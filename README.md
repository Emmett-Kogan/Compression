# Bitmask-based Code Compression
For the sake of the proffessor, I will public my solution after it is overdue and no longer accepted. But this seems like it would be fun to do in C, and then do again in Rust when I go to learn that next week.

## Contributors
1. Emmett Kogan

## Useful snippets for later
```
    // Get each line of the input file
    char buffer[34];
    while(fgets(buffer, 34, fptr_in)) {
        // If "xxxx", then need to load dictionary feon file
        if (!strncmp(buffer, "xxxx", 4)) {
            load_dictionary();
            // We also no longer need to read lines
            break;
        }
        
        uint32_t tmp = btoi(buffer, 32);
        printf("%032b\n", tmp);
        lines.push_back(tmp);
        if(counts.find(tmp) != counts.end())
            counts[tmp]++;
        else
            counts[tmp] = 1;
    }

    // If compressing then need to initialize the dictionary
    if (arg == 1) {
        write_dictionary();
    }


        for (int i = 0; i < 8; i++)
        printf("%03b\n", i);

```

11111000111111111111001111111111 0
11111110000000100000000000001000 1
01100000000000000000000000000010 2
11010000111111111111001000111111 3
00000000000000000000000000000000 4
11010000111111111111001000000000 5
11011111111111111111111111111101 6
11101111111111111111111111110111 7
00000000011111100000000000011100 8
11111000000000000111111111111111 9
11001000111110110101011110011111 a
00000000000000001101000000000000 b
11011111111111111111111111101111 c
00010000000000000000000000001000 d
01010000000000000000000000000010 e
11111111111111111000000000000000 f

11111000111111111111001111111111 0
11111110000000100000000000001000 1
01100000000000000000000000000010 2
11010000111111111111001000111111 3
00000000000000000000000000000000 4
11010000111111111111001000000000 5
11011111111111111111111111111101 6
11101111111111111111111111110111 7
00000000011111100000000000011100 8
11111000000000000111111111111111 9
01010000000000000000000000000010 a
11111111111111111000000000000000 b
00000000000000001000000000000000 c
01111000000000000111111111111111 d
11100001111111111111111111110111 e
11100000111111111111001111111111 f